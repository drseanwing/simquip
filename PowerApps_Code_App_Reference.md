# Power Apps Code Apps: the complete technical guide

**Power Apps Code Apps is a GA feature that lets developers build full single-page applications using React, Vue, or any JavaScript framework, then host and govern them within Power Platform.** Announced generally available on February 5, 2026, Code Apps bridges the gap between professional web development and enterprise low-code governance — developers get full code-first flexibility while IT retains Entra ID authentication, DLP enforcement, Conditional Access, and connector-level controls. Unlike canvas or model-driven apps built with Power Fx, Code Apps are standard TypeScript/JavaScript SPAs scaffolded with Vite, developed locally in VS Code, and deployed via `pac code push`. The **`@microsoft/power-apps`** npm SDK provides access to **1,400+ Power Platform connectors** directly from JavaScript, with auto-generated typed TypeScript services for CRUD operations against Dataverse, SQL Server, SharePoint, and other data sources.

---

## Architecture: three layers powering every code app

Code Apps use a **three-layer runtime architecture** that separates concerns cleanly between developer code, platform SDK, and hosting infrastructure.

**Layer 1 — Your Code.** A standard SPA built with any framework (React, Vue, Angular, or vanilla JS/TS). The official quickstart uses Vite with the `react-ts` template. Developers maintain full control over the DOM, UI components, routing, and state management. There are no proprietary abstractions — this is standard web development.

**Layer 2 — The Power Apps SDK.** The `@microsoft/power-apps` npm package (v1.0.3 at GA) exposes initialization APIs and manages auto-generated data services. Key imports include `@microsoft/power-apps/app` for the `initialize()` function and `@microsoft/power-apps/data` for `getClient()`. When developers add data sources via the CLI, the SDK generates strongly-typed TypeScript models in `/generated/models/` and service files in `/generated/services/` with methods like `getAll()`, `get()`, `create()`, `update()`, and `delete()`.

**Layer 3 — The Power Apps Host.** The platform manages end-user **Entra ID authentication**, DLP enforcement, Conditional Access, tenant isolation, and connector routing. All data operations flow through Power Platform's backend infrastructure — the app never makes direct API calls to data sources. The app URL follows the pattern `https://apps.powerapps.com/play/e/{environment-id}/a/{app-id}`.

During development, two servers run simultaneously: the **Vite dev server** on port 3000 (with HMR) and the **`pac code run` middleware** that proxies authentication and connector requests locally. This allows developers to iterate with live data without deploying.

### How Code Apps differ from canvas and model-driven apps

| Dimension | Canvas apps | Model-driven apps | Code Apps |
|---|---|---|---|
| Development model | Low-code drag-and-drop | Data-model-first declarative | Code-first IDE (VS Code) |
| Language | Power Fx | Power Fx + config | TypeScript / JavaScript |
| UI framework | Proprietary controls | Auto-generated from schema | React, Vue, Angular, or any SPA |
| Build tools | None (cloud-authored) | None (cloud-authored) | Vite, webpack, or any bundler |
| Mobile support | Power Apps mobile app | Power Apps mobile app | **Web browser only** |
| License required | Standard or Premium | Premium | **Premium** ($20/user/month) |

### Project structure

A typical Code Apps project built with the React-TypeScript template contains:

```
MyCodeApp/
├── src/
│   ├── App.tsx                    # Main application component
│   ├── main.tsx                   # Entry point — wraps App in PowerProvider
│   ├── PowerProvider.tsx          # SDK initialization wrapper
│   └── generated/                 # Auto-generated by PAC CLI
│       ├── models/
│       │   └── AccountsModel.ts   # TypeScript type definitions
│       └── services/
│           └── AccountsService.ts # CRUD service methods
├── .power/                        # Power Platform metadata
├── power.config.json              # App metadata (IDs, connections, build config)
├── vite.config.ts                 # Must set port 3000, base: "./"
├── package.json                   # Dependencies incl. @microsoft/power-apps
└── dist/                          # Build output (deployed via pac code push)
```

The `power.config.json` file contains the app ID, environment ID, build path (`./dist`), entry point (`index.html`), local app URL, and connection references. It is generated by `pac code init` and should not be edited manually for app logic.

---

## Setting up the development environment from scratch

Getting started requires five software prerequisites and one administrative toggle. **Node.js (LTS)**, **Git**, **Visual Studio Code**, **the Power Platform Tools VS Code extension** (which bundles the PAC CLI), and optionally the **.NET SDK** (if installing PAC CLI via `dotnet tool install --global Microsoft.PowerApps.CLI.Tool`). The VS Code extension is the recommended installation path as it provides PAC CLI access, an auth profile manager, and an environment browser panel directly in the editor.

### Enabling code apps on your environment

Code Apps must be explicitly enabled per environment. Navigate to the **Power Platform Admin Center** → Manage → Environments → select your environment → Settings → Product → Features → toggle **"Enable code apps"** to ON. If the setting isn't visible, appending `?ecs.ShowCodeAppSetting=true` to the admin center URL may surface it. Only Power Platform admins and environment admins can change this setting.

### Step-by-step first code app creation

```bash
# 1. Scaffold a Vite + React + TypeScript project
npm create vite@latest MyApp -- --template react-ts
cd MyApp
npm install
npm i --save-dev @types/node

# 2. Configure Vite for port 3000 (required by SDK)
# In vite.config.ts: set server.port to 3000, base to "./"

# 3. Authenticate and select environment
pac auth create                    # Interactive browser login
pac env select -env <environment-URL>

# 4. Initialize the code app
pac code init --displayName "My App"

# 5. Install the Power Apps SDK
npm install --save @microsoft/power-apps

# 6. Add PowerProvider.tsx and wrap App in main.tsx
# 7. Update package.json dev script:
#    "dev": "start pac code run && vite"

# 8. Run locally
npm run dev

# 9. Build and deploy
npm run build
pac code push
```

The `PowerProvider.tsx` wrapper calls `initialize()` from the SDK to signal the host that the app is ready. Without this initialization call, connector-based data operations will fail. The official reference implementation is available at `github.com/microsoft/PowerAppsCodeApps/blob/main/docs/assets/PowerProvider.tsx`.

**Browser note (December 2025+):** Chrome and Edge now block requests from public origins to localhost. Developers may need to grant browser permissions or configure enterprise policies like `LocalNetworkAccessAllowedForUrls` for local development.

---

## PAC CLI command reference for code apps

The PAC CLI's `pac code` command group is purpose-built for Code Apps. Below is the complete reference with every available subcommand.

### Core code app commands

| Command | Purpose | Key parameters |
|---|---|---|
| `pac code init` | Initialize a code app in the current directory | `--displayName` (required), `--environment`, `--description`, `--buildPath`, `--fileEntryPoint`, `--region` |
| `pac code push` | Publish built app to Power Platform | `--environment`, `--solutionName` |
| `pac code run` | Start local SDK middleware server | `--port`, `--appUrl` |
| `pac code list` | List code apps in current environment | — |
| `pac code add-data-source` | Add a connector/table as data source | `--apiId`, `--connectionId`, `--table`, `--dataset`, `--storedProcedure` |
| `pac code delete-data-source` | Remove a data source | `--dataSourceName`, `--apiId` |
| `pac code list-connection-references` | List connection refs in a solution | `--solutionId` |
| `pac code list-datasets` | List datasets for a connector | `--apiId`, `--connectionId` |
| `pac code list-tables` | List tables for a connector/dataset | `--apiId`, `--connectionId`, `--dataset` |
| `pac code list-sql-stored-procedures` | List SQL stored procedures | `--connectionId`, `--dataset` |

### Authentication commands

```bash
pac auth create                              # Interactive browser login
pac auth create --deviceCode                 # Device code flow (for Codespaces/SSH)
pac auth create --applicationId <id> \
  --clientSecret <secret> --tenant <id>      # Service principal (CI/CD)
pac auth create --managedIdentity            # Azure managed identity
pac auth list                                # List all profiles
pac auth select --index 2                    # Switch active profile
pac auth delete --index 1                    # Remove profile
```

### Solution management for deployment

```bash
pac solution list                            # List solutions
pac solution export --path ./sol.zip \
  --name MySolution --managed true           # Export managed solution
pac solution import --path ./sol.zip         # Import solution
pac solution init --publisher-name pub \
  --publisher-prefix pfx                     # Initialize solution project
pac solution check --path ./sol.zip          # Run solution checker
```

---

## Connecting to Power Platform data sources

Code Apps access data through auto-generated TypeScript services that wrap Power Platform connectors. The workflow is consistent across data sources: add a data source via CLI, the SDK generates typed models and services, then import and call those services from your React/Vue components.

### Dataverse integration

Dataverse has a dedicated integration path using the `dataverse` API identifier:

```bash
pac code add-data-source -a dataverse -t account
```

This generates `AccountsModel.ts` and `AccountsService.ts` with strongly-typed CRUD methods:

```typescript
import { AccountsService } from './generated/services/AccountsService';
import type { Accounts } from './generated/models/AccountsModel';

// Read with OData-style query options
const result = await AccountsService.getAll({
  select: ['name', 'accountnumber', 'address1_city'],
  filter: "address1_country eq 'USA'",
  orderBy: ['name asc'],
  top: 50
});

// Create
await AccountsService.create({ name: "Contoso", statecode: 0 } as Omit<Accounts, 'accountid'>);

// Update
await AccountsService.update(accountId, { telephone1: "555-0123" });

// Delete
await AccountsService.delete(accountId);
```

The `IGetAllOptions` interface supports `select`, `filter`, `orderBy`, `top`, `skip`, `skipToken` (pagination), and `maxPageSize`. **Unsupported Dataverse features** at GA include formatted values for option sets, lookup fields (including polymorphic), Dataverse actions/functions, FetchXML queries, and alternate key access.

### SQL Server integration

```bash
pac code add-data-source -a "shared_sql" -c "<connectionId>" \
  -t "[dbo].[Inventory]" -d "server.database.windows.net,mydb"
```

SQL stored procedures are also supported via the `--storedProcedure` flag. All SQL access flows through the Power Platform `shared_sql` connector — there are no direct JDBC/ODBC connections.

### SharePoint integration

SharePoint lists are treated as tabular data sources. The dataset is the site URL and the table ID is the list identifier:

```bash
pac code add-data-source -a "shared_sharepointonline" -c "<connectionId>" \
  -t "<listId>" -d "<siteUrl>"
```

Generated services support full CRUD plus `getReferencedEntity()` for choice/lookup columns. **Not supported:** document processing APIs, permission changes, or SharePoint forms integration.

### Non-tabular connectors

Non-tabular connectors like Office 365 Users generate action-based services:

```typescript
import { Office365UsersService } from './generated/services/Office365UsersService';
const profile = (await Office365UsersService.MyProfile_V2("id,displayName")).data;
```

**Custom connectors** follow the same pattern — create the connector in Power Platform, establish a connection, then use `pac code add-data-source` with the custom connector's API name. Code Apps can also invoke APIs **outside** the connector system via standard `fetch()` calls, though this bypasses platform governance.

---

## Every known hard limitation at GA

Code Apps shipped to GA with significant capabilities but also clearly documented constraints. The following limitations are confirmed from official Microsoft documentation and community-reported issues.

### Platform and runtime constraints

- **Web browser only** — not supported on Power Apps mobile app or Power Apps for Windows
- **No Content Security Policy (CSP)** support yet
- **No Storage SAS IP restriction** support
- **No Power Platform Git integration** — source code cannot be synced via the platform's native Git features
- **No Solution Packager** tool support for code apps
- **Not saved to a solution by default** — must be manually added after `pac code push`
- **No native Azure Application Insights integration** (can be added manually as a standard web telemetry library)
- **No Power BI data integration** (PowerBIIntegration function unavailable)
- **No SharePoint forms integration**
- **No PWA support** (requested as GitHub issue #191)
- **No custom domains** — apps are hosted on the Power Platform managed endpoint only
- **Port 3000 required** for local SDK development

### Licensing and access

**End-users require a Power Apps Premium license** at $20/user/month. The per-app plan ($5/user/app) was discontinued for new purchases as of January 2, 2026. Pay-As-You-Go at **$10/active user/app/month** remains available. Microsoft 365 seeded licenses do **not** include Code Apps access.

### API request limits

Power Platform standard request limits apply to all connector calls from Code Apps:

| License tier | Requests per 24 hours |
|---|---|
| Power Apps Premium | **40,000** |
| Pay-As-You-Go / per-app | 6,000 |
| Dynamics 365 Enterprise | Varies (pooled) |

Dataverse imposes **service protection limits** evaluated in a 5-minute sliding window: limits on concurrent connections per user, API requests per connection, and execution time per connection. Exceeding these returns **HTTP 429** with retry-after headers.

### Dataverse-specific limitations

Unsupported: formatted values/display names for option sets, lookup fields (including polymorphic), Dataverse actions and functions, FetchXML queries, alternate key support, and schema definition CRUD operations. Deleting Dataverse data sources via CLI is also unsupported at GA.

### Known community-reported issues (GitHub)

The official repository at `github.com/microsoft/PowerAppsCodeApps` tracked **24 open issues** at GA, including CORS issues with SharePoint images (#198), display problems when embedding in model-driven app iframes (#199), mobile redirect issues (#195), routing failures with TanStack Router (#192), and ALM anomalies with Azure DevOps pipelines (#200).

---

## Antipatterns that undermine code app quality

Drawing from Microsoft guidance, PCF best practices, Dataverse query documentation, and community experience, these are the most damaging patterns to avoid.

**Fetching all data at startup.** Loading entire tables into client-side state during initialization creates slow startup times and excessive API consumption. Use server-side filtering, pagination via `top`/`skip`/`skipToken`, and lazy loading. Each API call counts against daily request limits — over-fetching directly erodes your **40,000-request daily budget**.

**Deploying development builds.** Vite development builds include source maps and unminified code that can be orders of magnitude larger than production bundles. Always run `npm run build` (which executes `tsc -b && vite build`) before `pac code push`. Development builds may be blocked from deployment entirely due to size.

**Ignoring delegation for Dataverse queries.** Non-delegable queries download data client-side and process only the first 500 (default) or 2,000 records. Using leading wildcards (`%search%`) in filters, filtering on calculated/computed columns, or using unsupported filter functions causes full table scans or silent data truncation.

**Storing sensitive data in app code.** Since published code is hosted on a publicly accessible endpoint, embedding secrets, tokens, API keys, or organizational data in your JavaScript bundle is a security vulnerability. Always retrieve sensitive data through authenticated connector calls.

**Implementing custom authentication.** Code Apps provide zero-config Entra ID authentication. Building custom auth flows is unnecessary, increases complexity, and can conflict with the platform's security model. Trust the host layer.

**Excessive connector connections.** Canvas app guidance recommends no more than **30 data connections** per app — each requires user consent and increases startup latency. This principle applies equally to Code Apps. Minimize the number of distinct data sources.

**Not implementing retry logic for 429 errors.** Dataverse service protection limits and connector throttling return HTTP 429 responses. Apps must implement exponential backoff; without it, cascading failures result in degraded user experience.

**Calling Power Automate for simple operations.** Each Power Automate invocation adds approximately **0.6 seconds of overhead** plus network latency. When a direct connector call can accomplish the same task, use it instead.

---

## Code examples and available resources

### Official GitHub repository

The primary resource is `github.com/microsoft/PowerAppsCodeApps` (MIT license, **275+ stars**, 78 forks, 226 commits, 15 contributors). It contains:

- **HelloWorld** — minimal starter demonstrating SDK initialization and basic rendering
- **FluentSample** — full React + Fluent UI sample with data fetching, navigation, and connector integration
- **`/docs/assets/PowerProvider.tsx`** — the essential SDK wrapper component
- **`/sessions/ppcc2025/`** — materials from Power Platform Community Conference 2025
- **Template scaffolding**: `npx degit github:microsoft/PowerAppsCodeApps/templates/vite my-app`

### Essential code patterns

**SDK initialization (PowerProvider.tsx pattern):**

```tsx
import { initialize } from '@microsoft/power-apps/app';
import { useState, useEffect, ReactNode } from 'react';

export default function PowerProvider({ children }: { children: ReactNode }) {
  const [ready, setReady] = useState(false);
  
  useEffect(() => {
    initialize().then(() => setReady(true));
  }, []);
  
  return ready ? <>{children}</> : <div>Loading...</div>;
}
```

**Entry point with Fluent UI:**

```tsx
import { FluentProvider, webLightTheme } from '@fluentui/react-components';
import PowerProvider from './PowerProvider';
import App from './App';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <PowerProvider>
      <FluentProvider theme={webLightTheme}>
        <App />
      </FluentProvider>
    </PowerProvider>
  </StrictMode>
);
```

**Data fetching with loading/error states:**

```tsx
const [accounts, setAccounts] = useState<Accounts[]>([]);
const [loading, setLoading] = useState(true);

useEffect(() => {
  AccountsService.getAll({ select: ['name', 'accountnumber'], top: 50 })
    .then(result => setAccounts(result.data || []))
    .catch(err => console.error(err))
    .finally(() => setLoading(false));
}, []);
```

### npm packages

- **`@microsoft/power-apps`** (v1.0.3) — core SDK
- **`@microsoft/eslint-plugin-power-apps`** (v0.3.7) — ESLint rules for Power Apps patterns

### Community resources

- **Rajeev Pentyala's blog** (`rajeevpentyala.com`) — step-by-step guides for first code app and Dataverse CRUD
- **Scott Durow's Vibe Coding video** — GitHub Copilot-assisted Code Apps development
- **Aric Levin's blog** (`ariclevin.com`) — GA announcement coverage
- **Power Apps Guide** (`powerappsguide.com`) — PAC CLI command reference for code apps
- **Community Dataverse CRUD sample**: `github.com/RajeevPentyala/CodeAppsDVConnector`
- **Japanese development standard**: `github.com/geekfujiwara/CodeAppsDevelopmentStandard`

---

## Deployment and application lifecycle management

### Publishing and solution packaging

Code Apps deploy through a two-step process: `npm run build` compiles the SPA into the `dist/` folder, then `pac code push` uploads the built assets to Power Platform. The app becomes immediately playable at its Power Apps URL. However, **code apps are not saved to a solution by default**. To include them in a solution for ALM:

1. Run `pac code push --solutionName MySolution` to associate during push, or
2. Navigate to Power Apps Maker Portal → Solutions → select your solution → Add existing → App → Code app

Solutions follow the standard managed/unmanaged paradigm: unmanaged in development, exported as managed for downstream environments. Power Platform Pipelines handle the promotion from dev → test → production, prevalidating against target environments and managing connection references.

### CI/CD pipeline integration

**Azure DevOps** pipelines use Power Platform Build Tools tasks (`PowerPlatformExportSolution`, `PowerPlatformPackSolution`, `PowerPlatformImportSolution`). Service principal authentication (`pac auth create --applicationId --clientSecret --tenant`) enables headless deployments.

**GitHub Actions** leverage the GitHub Actions for Power Platform marketplace action set. Secrets are stored in GitHub repository settings; workflows follow an export → artifact → deploy pattern.

### Current ALM limitations

Code Apps do **not** support Solution Packager (for source-controlled solution decomposition) or Power Platform Git integration. This means the traditional ALM pattern of unpacking solutions into source control is not available — source code must be managed separately in Git, with the built bundle deployed through `pac code push` as part of your pipeline.

---

## Testing approaches for code apps

Since Code Apps are standard web applications, the entire ecosystem of web testing tools applies — with some platform-specific considerations.

**Local development and debugging** uses the dual-server setup (`vite` + `pac code run`). Vite's Hot Module Replacement provides instant feedback during development. Browser DevTools (F12) work fully: console logging, network inspection, React DevTools extension, and performance profiling are all available. Source maps in development mode enable TypeScript debugging in the browser.

**Unit testing** works with standard React testing libraries. **Vitest** (Vite's native test runner) integrates seamlessly with the project setup. **Jest** with React Testing Library is equally viable. The auto-generated service files (`AccountsService`, etc.) can be mocked to isolate component logic from data layer dependencies.

**Integration and end-to-end testing** can be accomplished with **Playwright** or **Cypress**, since Code Apps render as standard SPAs in the browser. Deploy to a test environment and run tests against real connectors and data. Microsoft's **Power Apps Test Engine** currently focuses on canvas apps but has roadmap items for broader support.

**No dedicated test harness** exists for Code Apps (unlike PCF components which have `npm start watch`). The local development environment serves as the primary development harness. The FluentSample in the GitHub repo demonstrates a pattern of using mock data by default, enabling development and testing without live connectors.

---

## GA status confirmed, with active feature development ahead

**Code Apps reached General Availability on February 5, 2026**, announced by Jordan Chodak on the Microsoft Power Platform Blog. The feature was previewed at Microsoft Ignite 2025 (November 2025) and underwent an Early Access Preview period with monthly community office hours through late 2025 and early 2026.

Some Microsoft Learn documentation pages still carry "(preview)" labels — this is a documentation update lag following the GA announcement rather than a reflection of the feature's actual status. The GA blog post is authoritative.

### What's actively being addressed

Based on the GitHub issue tracker and documentation gaps, several areas are under active development: Power Platform Git integration support, Solution Packager compatibility, improved ALM workflows, Content Security Policy implementation, mobile browser experience improvements, expanded Dataverse feature support (lookup fields, FetchXML, actions/functions), and PWA capability. The `@microsoft/power-apps` SDK continues to evolve — version 1.0.3 at GA, with community reports of improving React 19 compatibility.

### Conclusion

Code Apps represents a fundamental shift in Power Platform's developer story. For the first time, professional web developers can build production SPAs with React or Vue while inheriting Power Platform's enterprise governance layer — Entra ID authentication, DLP policies, 1,400+ managed connectors, and centralized admin controls — without managing any cloud infrastructure. The three-layer architecture (your code → SDK → host) cleanly separates developer freedom from platform responsibility. The key trade-offs are clear: **Premium licensing required**, web-only delivery (no mobile app), limited ALM tooling compared to mature canvas app workflows, and ongoing gaps in Dataverse feature coverage. For organizations already invested in Power Platform seeking to empower pro-dev teams while maintaining IT governance, Code Apps fills a previously unserved niche between fully custom Azure-hosted apps and low-code canvas solutions.